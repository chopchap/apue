# slide notes
---
## Interprocess Communication Intro
- forms:
  - two processes reading from/writing to a file on a shared file system
    - asynchronous
    - bidirectional
    - related / unrelated processes
    - variable data
  - signals
    - asynchronous
    - related / unrelated processes
  - semaphores (primarily used as a locking mechanism)
    - asynchronous
    - related / unrelated processes
  - shared memory / message queues
    - asynchronous
    - bidirectional
    - related / unrelated processes
    - variable data
  - pipes
    - synchronous
    - related processes
    - variable data
  - fifos
    - synchronous
    - related / unrelated processes
    - variable data
  - socketpairs
    - synchronous
    - bidirectional
    - related processes
    - variable data
  - sockets
    - synchronous
    - bidirectional
    - related / unrelated processes
    - network communication
    - variable data
## System V IPC
- System V IPC mechanisms use specific IPC kernel structures, utilizing an _identifier_ and a _key_ to reference these in-kernel resources, and as a result, they are obviously and necessarily restricted to communications between processes on the _same_ system.
- System V IPC structures are persistent, the structures will remain present even after a process that created or accessed them has terminated.
- semephores:
  - use `semget(2)`, `semctl(2)`, and `semop(2)`.
  - see `semdemo.c`
  - `$ ipcs -s`: cmd displays information about active semaphores.
  - IPC data flow
  ![IPC data flow](https://github.com/chopchap/apue/blob/main/images/IPC%20data%20flow.png?raw=true)
- shared memory:
![shared memory](https://github.com/chopchap/apue/blob/main/images/shared%20memory.png?raw=true)
  - fastest form of IPC
  - access to shared region of memory often controlled using semaphores
  - obtain a shared memory identifier by using `shmget(2)`
  - attach shared memory segment to a processes address space by callying `shmat(2)`
  - detail it using `shmdt(2)`
  - catch-all for shared memory operations: `shmctl(2)`
- message queues:
  - linked list of messages stored in kernel space
  - create or open existing queue using `msgget(2)`
  - add message at end of queue using `msgsnd(2)`
  - receive message from queue using `msgrcv(2)`
  - control queue properties using `msgctl(2)`
  - POSIX message queues: mq(3)
    - message queues are identified by a named identifier (no `ftok(3) needed`)
    - message queues may or may not be exposed in the filesystem (e.g., /dev/mqueue)
    - `mqsend(3)` and `mqreceive(3)` allow both blocking and non-blocking calls
    - `mqsend(3)` lets you specify a priority; equal priority messages are queued as a FIFO, but higher priority messages are inserted before those of a lower priority
    - `mq(3)` provides an asynchronous notification mechanism: `mqnotify(3)`
## Pipes and FIFOs
- `pipe(2)`: takes as argument an array of file descriptors, which it will connect to the read and write end of this newly created pipe. (see `pipe[12].c`)
![pipe](https://github.com/chopchap/apue/blob/main/images/pipe.png?raw=true)
- since creating a pipe and then writing data into a second program is something that is needed quite often. Likewise, a program that executes another program and then reads the output from that program. Both are very common use cases, so we have `popen(3)`
- `mkfifo(2)`: the advantage of a fifo is that the data does not actually end up on disk and is consumed in sequence as it is written to the FIFO.
- pipe(2) and FIFOs
  - basis of the Unix Philosophy of building filters and operating on text streams
  - pipes require a common ancestor, FIFOs do not
  - data written into a pipe is no longer line buffered
  - can have multiple readers/writers (PIPE_BUF bytes are guaranteed to not be interleaved)
  - Behavior after closing one end:
    - read(2) from a pipe whose write end has been closed returns 0 after all data has been read
    - write(2) to a pipe whose read end has been closed generates SIGPIPE; if caught or ignored, write(2) returns an error and sets errno to EPIPE.
