# slide notes
---
## Interprocess Communication Intro
- forms:
  - two processes reading from/writing to a file on a shared file system
    - asynchronous
    - bidirectional
    - related / unrelated processes
    - variable data
  - signals
    - asynchronous
    - related / unrelated processes
  - semaphores (primarily used as a locking mechanism)
    - asynchronous
    - related / unrelated processes
  - shared memory / message queues
    - asynchronous
    - bidirectional
    - related / unrelated processes
    - variable data
  - pipes
    - synchronous
    - related processes
    - variable data
  - fifos
    - synchronous
    - related / unrelated processes
    - variable data
  - socketpairs
    - synchronous
    - bidirectional
    - related processes
    - variable data
  - sockets
    - synchronous
    - bidirectional
    - related / unrelated processes
    - network communication
    - variable data
## System V IPC
- System V IPC mechanisms use specific IPC kernel structures, utilizing an _identifier_ and a _key_ to reference these in-kernel resources, and as a result, they are obviously and necessarily restricted to communications between processes on the _same_ system.
- System V IPC structures are persistent, the structures will remain present even after a process that created or accessed them has terminated.
- semephores:
  - use `semget(2)`, `semctl(2)`, and `semop(2)`.
  - see `semdemo.c`
  - `$ ipcs -s`: cmd displays information about active semaphores.
  - IPC data flow
  ![IPC data flow](https://github.com/chopchap/apue/blob/main/images/IPC%20data%20flow.png?raw=true)
- shared memory:
![shared memory](https://github.com/chopchap/apue/blob/main/images/shared%20memory.png?raw=true)
  - fastest form of IPC
  - access to shared region of memory often controlled using semaphores
  - obtain a shared memory identifier by using `shmget(2)`
  - attach shared memory segment to a processes address space by callying `shmat(2)`
  - detail it using `shmdt(2)`
  - catch-all for shared memory operations: `shmctl(2)`
- message queues:
  - linked list of messages stored in kernel space
  - create or open existing queue using `msgget(2)`
  - add message at end of queue using `msgsnd(2)`
  - receive message from queue using `msgrcv(2)`
  - control queue properties using `msgctl(2)`
  - POSIX message queues: mq(3)
    - message queues are identified by a named identifier (no `ftok(3) needed`)
    - message queues may or may not be exposed in the filesystem (e.g., /dev/mqueue)
    - `mqsend(3)` and `mqreceive(3)` allow both blocking and non-blocking calls
    - `mqsend(3)` lets you specify a priority; equal priority messages are queued as a FIFO, but higher priority messages are inserted before those of a lower priority
    - `mq(3)` provides an asynchronous notification mechanism: `mqnotify(3)`
## Pipes and FIFOs
- 
